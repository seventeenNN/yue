# GPIO

## 什么是GPIO

GPIO 是通用输入输出（General Purpose Input/Output）的缩写。它是一种在微控制器或微处理器上常见的硬件接口，允许用户通过编程来控制和读取数字信号。

GPIO引脚可以配置为多种模式，以适应不同的应用需求。

**输入模式（Input Mode）：**

```
    浮空输入（Floating Input）：GPIO 引脚对外部电路呈现高阻抗状态，用于读取外部设备的状态。

    上拉（Pull-Up）：通过内部上拉电阻将 GPIO 引脚拉高到高电平，适用于按钮等设备。

    下拉（Pull-Down）：通过内部下拉电阻将 GPIO 引脚拉低到低电平，适用于按钮等设备。
```

**输出模式（Output Mode）：**

```
    推挽输出（Push-Pull）：GPIO 引脚可以输出高电平或低电平，提供较强的驱动能力。

    开漏输出（Open-Drain）：GPIO 引脚只能输出低电平或高阻态，需要外部上拉电阻输出高电平。

```
**模拟模式（Analog Mode）：**

```
当 GPIO 引脚配置为模拟模式时，通常是针对模拟输入功能。

在这种模式下，GPIO 引脚的数字输入输出功能会被禁用，以便为模拟信号提供一个干净的信号路径。

虽然模拟模式通常指的是模拟输入,但该微控制器也支持模拟输出模式。

在这种模式下，GPIO 引脚可以通过 DAC 将数字信号转换为模拟信号。

```

**复用功能（Alternate Function）：**

```
常见的复用功能包括：
串行通信接口：  UART（Universal Asynchronous Receiver/Transmitter）：用于异步串行通信。

               SPI（Serial Peripheral Interface）：用于同步串行通信。

               I2C（Inter-Integrated Circuit）：用于同步串行通信，支持多设备连接。

模拟功能：      ADC（Analog-to-Digital Converter）：用于读取模拟信号并转换为数字信号。

               DAC（Digital-to-Analog Converter）：用于将数字信号转换为模拟信号。

定时器和 PWM：  PWM（Pulse Width Modulation）：用于生成脉宽调制信号，常用于控制电机、LED 亮度等。

               定时器（Timer）：用于生成精确的时间延迟或周期性事件。

外部中断：配置 GPIO 引脚作为外部中断输入，用于检测外部事件并触发中断服务程序。

其他特殊功能：  如 CAN 总线、USB 控制器、以太网控制器等。

```



### 推挽和开漏

```

P                       Q                          输出

打开                  关闭                          高电平

                                                                  }  推挽
关闭                  打开                          低电平

                                                                 }开漏
关闭                  关闭                        浮空/高组态

```


#### 开漏的作用

（*开漏一般会外部配置一个上拉电阻*）

**多设备共享总线：**

开漏输出允许多个设备共享同一总线，因为每个设备的输出引脚在逻辑高电平时都处于高阻态。通过外部上拉电阻，总线可以在没有设备驱动时保持高电平状态。

例如，I2C 总线就是使用开漏输出配置，允许多个设备共享同一总线进行通信。

**电平转换：**

开漏输出可以用于实现不同电平标准之间的转换。通过选择合适的外部上拉电阻和电源电压，可以将开漏输出引脚的电平转换为所需的电平标准。

例如，将 3.3V 的开漏输出通过外部上拉电阻连接到 5V 电源，可以实现 3.3V 到 5V 的电平转换。

避免短路：

在某些情况下，如果两个设备的输出引脚同时为高电平，可能会导致短路。使用开漏输出可以避免这种情况，因为输出引脚在逻辑高电平时都处于高阻态。

简化电路设计：

开漏输出可以简化电路设计，特别是在需要多个设备共享总线或进行电平转换的场合。通过使用外部上拉电阻，可以灵活地配置输出引脚的电平。

提高抗干扰能力：

开漏输出在逻辑高电平时处于高阻态，可以减少对总线的干扰，提高系统的抗干扰能力。


### 直接在GPIO_ODR中改变值的大小和通过GPIO_BSRR改变有什么区别

**GPIO_ODR（GPIO Output Data Register）：**

功能：GPIO_ODR 寄存器用于直接读取或写入 GPIO 引脚的输出状态。写入 GPIO_ODR 寄存器的值会直接影响到所有 GPIO 引脚的输出状态。

使用方式：通过写入 GPIO_ODR 寄存器，可以同时设置或清除多个 GPIO 引脚的状态。例如，写入 0x00FF 会将 GPIO 引脚的低 8 位设置为高电平，高 8 位设置为低电平。

**原子性：GPIO_ODR 寄存器的写入操作不是原子性的，可能会在写入过程中产生中间状态，导致短暂的输出不稳定。**

**GPIO_BSRR（GPIO Bit Set/Reset Register）：**

功能：GPIO_BSRR 寄存器用于单独设置或清除 GPIO 引脚的状态。它分为两个部分：高 16 位用于清除（复位）引脚，低 16 位用于设置（置位）引脚。

使用方式：通过写入 GPIO_BSRR 寄存器，可以单独设置或清除每个 GPIO 引脚的状态。例如，写入 0x0001 会将 GPIO 引脚 0 设置为高电平，写入 0x00020000 会将 GPIO 引脚 1 清除为低电平。

原子性：GPIO_BSRR 寄存器的写入操作是**原子性**的，可以确保在设置或清除引脚状态时不会产生中间状态，从而避免输出不稳定。

区别总结：操作粒度：GPIO_ODR 寄存器用于同时设置或清除多个 GPIO 引脚的状态，而 GPIO_BSRR 寄存器用于单独设置或清除每个 GPIO 引脚的状态。

         原子性：GPIO_BSRR 寄存器的写入操作是原子性的，而 GPIO_ODR 寄存器的写入操作不是原子性的。

         使用场景：GPIO_ODR 寄存器适用于需要同时操作多个 GPIO 引脚的场景，而 GPIO_BSRR 寄存器适用于需要单独控制每个 GPIO 引脚的场景。

```c
GPIOA->ODR |= (1 << 0);
/*
它实际上包含两个步骤：
1.读取 GPIOA->ODR 的当前值。
2.将读取的值与 (1 << 0) 进行按位或运算，然后将结果写回 GPIOA->ODR。
*/
```

虽然这两个步骤在大多数情况下是连续执行的，但在多任务或中断环境中，这个操作可能不是原子操作。如果在这个操作过程中发生了中断或其他任务切换，可能会导致中间状态的出现，从而影响操作的完整性。

为了确保操作的原子性，可以使用 GPIOA->BSRR 寄存器，它允许单独设置或清除每个 GPIO 引脚的状态，并且这些操作是原子操作。


### GPIO 端口配置锁定寄存器 (GPIOx_LCKR)

只允许使用字访问

WR LCKR[16] = ‘1’ + LCKR[15:0]
WR LCKR[16] = ‘0’ + LCKR[15:0]
WR LCKR[16] = ‘1’ + LCKR[15:0]
RD LCKR
RD LCKR[16] = ‘1’（此读操作为可选操作，但它可确认锁定已激活）

**如果不进行这三步写操作，锁定机制将不会被激活，GPIO寄存器仍然可以被修改。这意味着，如果你只进行了一次或两次写操作，GPIO配置是不会被锁定的。**

（貌似是就必须这么做）

```c

    uint16_t lck_value = (1 << 0);  // 设置要锁定的 GPIO 引脚位
    GPIOA->LCKR = (1 << 16) | lck_value;  // 设置 LCKK[16] 和 LCKR[15:0]
    GPIOA->LCKR = (0 << 16) | lck_value;  // 清除 LCKK[16]，保持 LCKR[15:0]
    GPIOA->LCKR = (1 << 16) | lck_value;  // 再次设置 LCKK[16]，保持 LCKR[15:0]
    uint32_t lckr_value = GPIOA->LCKR;   // 读取 LCKR 寄存器的值
    if (lckr_value & (1 << 16)) {
        // 确认锁定已激活
    }

```

# DMA

**DMA（Direct Memory Access，直接存储器访问）** 是一种计算机系统中的硬件功能，它允许外部设备直接访问系统内存而不经过中央处理器（CPU）的干预。

### DMA的主要特点和优点：

1. **减少CPU负载**：
   - DMA可以在外设和内存之间直接传输数据，而不需要CPU参与。这使得CPU可以腾出时间来处理其他任务，从而提高系统效率。

2. **高速数据传输**：
   - 由于DMA不需要CPU处理每一个字节的数据传输，它可以比通过CPU处理的传统方式更快地进行大批量数据传输。

3. **多种传输模式**：
   - **单次传输模式**：每传输一个数据，DMA控制器请求一次总线使用权。这种模式下，CPU和DMA控制器轮流使用总线。
   - **突发传输模式**：DMA控制器在获得总线控制权后，持续传输多个数据，直到完成任务或其他设备请求总线使用权。
   - **循环传输模式**：DMA传输完成后，可以自动重新开始传输（常用于音频数据处理）。

### DMA的工作流程：

1. **配置DMA控制器**：CPU首先配置DMA控制器，包括源地址、目标地址、数据传输大小等参数。

2. **启动传输**：CPU启动DMA传输。

3. **数据传输**：DMA控制器接管总线控制权，直接在外设和内存之间进行数据传输，而不需要CPU参与。

4. **传输完成**：当数据传输完成时，DMA控制器可以产生一个中断通知CPU，表明传输已经完成。

### DMA的应用：

DMA广泛应用于需要高效数据传输的场景，如：
- **音频和视频数据处理**：例如音频播放，视频捕获等。
- **数据采集**：如ADC（模数转换器）采集数据后，直接通过DMA传输到内存。
- **存储设备**：如硬盘、SD卡等的数据读写操作。

###



